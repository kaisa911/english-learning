# 使用现代纯 JavaScript 进行内存高效 DOM 操作的模式

[原文链接](https://frontendmasters.com/blog/patterns-for-memory-efficient-dom-manipulation/)

![1](https://i0.wp.com/frontendmasters.com/blog/wp-content/uploads/2024/04/hero-1.jpg?w=1792&ssl=1)

Article Series

> [Writing a TodoMVC App with Modern Vanilla JavaScript](https://frontendmasters.com/blog/vanilla-javascript-todomvc/) > [Patterns for Reactivity with Modern Vanilla JavaScript](https://frontendmasters.com/blog/vanilla-javascript-reactivity/) > [Patterns for Memory Efficient DOM Manipulation with Modern Vanilla JavaScript](https://frontendmasters.com/blog/patterns-for-memory-efficient-dom-manipulation/)

我将讨论在管理更新 DOM 时避免过多内存使用的最佳实践，以使你的应用程序[速度极快 ™️](https://frontendmasters.com/courses/blazingly-fast-js/?utm_source=boost&utm_medium=blog&utm_campaign=dom-patterns)。

## DOM：文档对象模型 – 简要概述

当你渲染 HTML 时，浏览器中那些被渲染元素的实时视图称为 DOM。这是正是你在开发工具“Elements” 检查器中看到的内容：
![2](https://i0.wp.com/frontendmasters.com/blog/wp-content/uploads/2024/04/DOM.jpg?w=1250&ssl=1)

它本质上是一棵树，里面的每个元素都是一片叶子。有一套完整的 API 专门用于修改此元素树。

以下是常见 DOM API 的快速列表：

<div style="color: rgb(250, 162, 162)">

- querySelector()
- querySelectorAll()
- createElement()
- getAttribute()
- setAttribute()
- addEventListener()
- appendChild()

</div>

这些方法附加到 document 中，因此你可以像使用 `const el = document.querySelector("#el");` 一样使用它们。这些方法也可以在所有其他元素上使用，因此，如果你有一个元素引用，你就可以使用这些方法，而且这些方法的能力是针对该元素的。

```javascript
const nav = document.querySelector('#site-nav');
const navLinks = nav.querySelectorAll('a');
```

这些方法在浏览器中可用来修改 DOM，但在服务器 JavaScript（如 Node.js）中却不可用，除非使用 js-dom 这样的 DOM 模拟器。

作为一个行业，我们已经将大部分直接操作 DOM 的工作交给了框架。所有 JavaScript 框架（React、Angular、Vue、Svelte 等）都在内部的机制中使用这些 API。虽然我认识到框架的生产力优势往往大于手动操作 DOM 可能带来的性能提升，但我还是想在本文中揭开这些 API 的神秘面纱。

## 为什么要自己操作 DOM？

主要是性能原因。因为框架会添加一些不必要的数据结构和重新渲染，导致许多现代网络应用程序出现可怕的卡顿/冻结行为。出现这种情况是因为垃圾回收器要超负荷处理所有代码。

（自己操作 DOM 的）缺点则是需要更多代码来处理 DOM 操作。这可能会（让代码）变得复杂，这正是为什么使用围绕 DOM 的框架和抽象化工具，而不是手动操作 DOM，能提供更好的开发体验。
无论如何，总有一些情况下你可能需要额外的性能。这就是本指南的目的所在。

## VS Code 基于手动 DOM 操作构建

Visual Studio Code 就是此类案例之一。 VS Code 使用普通 JavaScript 编写，“尽可能接近 DOM”。像 VS Code 这样大的项目需要严格控制性能。由于大部分功能都在插件生态系统中，因此核心需要尽可能核心和轻量级，并负责其广泛采用。

Visual Studio Code 就是这样一个例子。VS Code 使用纯 JavaScript 编写，以“尽可能接近 DOM”。像 VS Code 这样庞大的项目需要对性能有严格的控制。由于插件生态系统拥有巨大的能力，核心部分需要尽可能地精简和轻量，这也是它被广泛使用的原因。

<iframe width="560" height="315" src="https://www.youtube.com/embed/gnKzJRr-rd0?si=e5T5HX555iSmn_AJ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

出于同样的原因，Microsoft Edge 最近也放弃了 React 。

如果你发现自己处于需要直接操作 DOM 以获得性能优势的情况——这比使用框架的编程层次要低——希望本文会有所帮助！

## 更高效 DOM 操作的技巧

### 更喜欢隐藏/显示而不是创建新元素

通过隐藏和显示元素来保持 DOM 不变，而不是使用 JavaScript 销毁和创建它们，这始终是性能更高的选择。

服务器渲染你的元素，并使用类（以及相应的 CSS 规则集）如`el.classList.add('show')`或`el.style.display = 'block'`隐藏/显示它。与使用 JavaScript 动态创建和插入元素相比，这种方法更为高效。因为大多数静态 DOM 由于减少了垃圾收集调用和复杂的客户端逻辑，其性能要显著提高。

如果可以避免的话，不要在客户端动态创建 DOM 节点。

但请务必考虑到辅助技术。如果你希望一个元素在视觉上被隐藏，并且对辅助技术也不可见，使用 `display: none;` 即可实现。然而，如果你想要隐藏一个元素，同时又希望它对辅助技术保持可见，请考虑使用[其他隐藏内容的方法](https://www.a11yproject.com/posts/how-to-hide-content/)。

### 在读取元素的内容时，优先选择 textContent 而不是 innerText

innerText 方法很酷，因为它知道元素的当前样式。它知道某个元素是否隐藏，并且仅在实际显示某些内容时才获取文本。它的问题是这个检查样式的过程会强制回流，并且速度较慢。

使用[element.textContent 读取内容比 element.innerText 快得多](https://www.measurethat.net/Benchmarks/Show/3618/0/createtextnode-vs-textcontent-vs-innertext-vs-innerhtml)，因此尽可能使用 `textContent` 来读取元素的内容。

### 使用 insertAdjacentHTML 而不是 innerHTML

[insertAdjacentHTML 方法比 innerHTML 快得多](https://www.measurethat.net/Benchmarks/Show/10750/0/insertadjacenthtml-vs-innerhtml#latest_results_block)，因为它不必在插入之前先销毁 DOM。该方法在放置新 HTML 的位置方面非常灵活，例如：

```js
el.insertAdjacentHTML('afterbegin', html);
el.insertAdjacentHTML('beforeend', html);
```

## 最快的方法是使用 insertAdjacentElement 或 appendChild

### 方法#1：使用 template 标签创建 HTML 模板并使用 appendChild 插入新的 HTML

这些最快的方法是追加已经完全构建的 DOM 元素。为此，一个常用的模式是利用 \<template\> 标签创建 HTML 模板来生成这些元素，然后通过 `insertAdjacentElement` 或 `appendChild` 方法将它们插入到 DOM 中。

```HTML
<template id="card_template">
  <article class="card">
    <h3></h3>
    <div class="card__body">
      <div class="card__body__image"></div>
      <section class="card__body__content"> </section>
    </div>
  </article>
</template>
```

```js
function createCardElement(title, body) {
  const template = document.getElementById('card_template');
  const element = template.content.cloneNode(true).firstElementChild;
  const [cardTitle] = element.getElementsByTagName('h3');
  const [cardBody] = element.getElementsByTagName('section');
  [cardTitle.textContent, cardBody.textContent] = [title, body];
  return element;
}

container.appendChild(
  createCardElement('Frontend System Design: Fundamentals', 'This is a random content')
);
```

你可以在全新的[前端系统设计课程](https://frontendmasters.com/courses/frontend-system-design/?utm_source=boost&utm_medium=blog&utm_campaign=dom-patterns)中亲眼见证这一过程，其中 Evgenni 从零开始构建了一个无限滚动的社交新闻源！

### 方法#2：使用 createDocumentFragment 和 appendChild 来批量插入

`DocumentFragment` 是一个轻量级的“空”文档对象，能够承载 DOM 节点。由于它不包含在活动的 DOM 树中，这使得它成为准备多个元素进行插入的理想选择。

```js
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);
}
document.getElementById('myList').appendChild(fragment);
```

这种方法通过一次插入所有元素而不是单独插入来最大限度地减少回流和重绘。

## 删除节点时管理引用

当你删除 DOM 节点时，你不希望存在阻止垃圾收集器清理关联数据的引用。我们可以使用 WeakMap 和 WeakRef 来避免泄漏引用。

### 使用 WeakMap 将数据关联到 DOM 节点

你可以使用 WeakMap 将数据关联到 DOM 节点。这样，如果稍后删除 DOM 节点，对数据的引用将永远消失。

```js
let DOMdata = { logo: 'Frontend Masters' };
let DOMmap = new WeakMap();
let el = document.querySelector('.FmLogo');
DOMmap.set(el, DOMdata);
console.log(DOMmap.get(el)); // { 'logo': 'Frontend Masters' }
el.remove(); // DOMdata is able to be garbage collected
```

使用弱映射可确保在删除 DOM 元素时不会保留对数据的引用。

## 使用 WeakRef 进行垃圾收集后清理

在下面的示例中，我们将创建一个 DOM 节点的 WeakRef ：

```js
class Counter {
  constructor(element) {
    // Remember a weak reference to the DOM element
    this.ref = new WeakRef(element);
    this.start();
  }

  start() {
    if (this.timer) {
      return;
    }

    this.count = 0;

    const tick = () => {
      // get the element from the weak reference, if it still exists
      const element = this.ref.deref();
      if (element) {
        console.log('Element is still in memory, updating count.');
        element.textContent = `Counter: ${++this.count}`;
      } else {
        // The element doesn't exist anymore
        console.log('Garabage Collector ran and element is GONE – clean up interval');
        this.stop();
        this.ref = null;
      }
    };

    tick();
    this.timer = setInterval(tick, 1000);
  }

  stop() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = 0;
    }
  }
}

const counter = new Counter(document.getElementById('counter'));
setTimeout(() => {
  document.getElementById('counter').remove();
}, 5000);
```

删除节点后，你可以观察控制台以查看实际垃圾收集何时发生，或者你可以使用开发人员工具中的“性能”选项卡自行强制进行垃圾收集：

![4](https://i0.wp.com/frontendmasters.com/blog/wp-content/uploads/2024/04/force-gc.jpg?w=1250&ssl=1)
然后你可以确定所有引用都已消失并且计时器已清理。

注意：尽量不要过度使用 Wea​​kRef——这种魔法确实是有代价的。如果你可以显式管理引用，则性能会更好。

## 清理事件监听器

### 使用 removeEventListener 手动删除事件

```js
function handleClick() {
  console.log('Button was clicked!');
  el.removeEventListener('click', handleClick);
}

// Add an event listener to the button
const el = document.querySelector('#button');
el.addEventListener('click', handleClick);
```

### 对 one 和 done 事件使用 once 参数

使用“once”参数可以实现与上面相同的行为：

```js
el.addEventListener('click', handleClick, {
  once: true,
});
```

在 `addEventListener` 中添加第三个参数，该参数是一个布尔值，表示添加后最多调用一次监听器。调用时侦听器会自动删除。

### 使用事件委托来绑定更少的事件

如果你在高度动态的组件中频繁地构建和替换节点，那么在构建节点的同时必须为它们设置各自的事件监听器，这将带来更高的成本。

相反，你可以将事件监听器绑定到更接近根节点的层级。由于事件会在 DOM 中向上冒泡，你可以检查 `event.target`（事件的原始目标），以便捕获并响应该事件。

使用 matches(selector)只匹配当前元素，因此它需要是叶子节点。

```js
const rootEl = document.querySelector('#root');
// Listen for clicks on the entire window
rootEl.addEventListener('click', function (event) {
  // if the element is clicked has class "target-element"
  if (event.target.matches('.target-element')) doSomething();
});
```

很可能，你将拥有类似`<div class="target-element"><p>...</p></div>`元素，在这种情况下，你需要使用.closest(element)方法。

```js
const rootEl = document.querySelector('#root');
// Listen for clicks on the entire window
rootEl.addEventListener('click', function (event) {
  // if the element is clicked has a parent with "target-element"
  if (event.target.closest('.target-element')) doSomething();
});
```

此方法使你不必担心动态注入元素后附加和删除侦听器。

## 使用 AbortController 解除事件组的绑定

```js
const button = document.getElementById('button');
const controller = new AbortController();
const { signal } = controller;

button.addEventListener('click', () => console.log('clicked!'), { signal });

// Remove the listener!
controller.abort();
```

你可以使用 AbortController 删除事件集。

```js
let controller = new AbortController();
const { signal } = controller;

button.addEventListener('click', () => console.log('clicked!'), { signal });
window.addEventListener('resize', () => console.log('resized!'), { signal });
document.addEventListener('keyup', () => console.log('pressed!'), { signal });

// Remove all listeners at once:
controller.abort();
```

感谢 Alex MacArthur 提供的[AbortController 代码示例](https://www.macarthur.me/posts/options-for-removing-event-listeners#using-abortcontroller)。

## 分析和调试

测量你的 DOM 以确保它不会太大。

以下是使用 Chrome DevTools 进行内存分析的简要指南：

1. 打开 Chrome 开发者工具
2. 转到“内存”选项卡
3. 选择“堆快照”并单击“拍摄快照”
4. 执行 DOM 操作
5. 再拍一张快照
6. 再拍一张快照比较快照以确定内存增长

![5](https://i0.wp.com/frontendmasters.com/blog/wp-content/uploads/2024/07/take-heap-snapshot_1920.png?w=1866&ssl=1)

需要关注的关键点:

- 意外保留的 DOM 元素
- 未清理的大型数组或对象
- 随着时间的推移内存使用量增加（潜在的内存泄漏）

你还可以使用“性能”选项卡来记录一段时间内的内存使用情况：

1. 转到“性能”选项卡
2. 在选项中勾选“内存”
3. 点击“录制”
4. 执行 DOM 操作
5. 停止记录并分析内存图

这将帮助你可视化内存分配并识别 DOM 操作期间潜在的泄漏或不必要的分配。

### JavaScript 执行时间分析

除了内存分析之外，Chrome DevTools 中的“性能”选项卡对于分析 JavaScript 执行时间也非常有用，这对于优化 DOM 操作代码至关重要。

使用方法如下：

1. 打开 Chrome DevTools 并转到“性能”选项卡
2. 单击录制按钮
3. 执行你想要分析的 DOM 操作
4. 停止录制

![6](https://i0.wp.com/frontendmasters.com/blog/wp-content/uploads/2024/07/Screenshot-2024-07-28-at-9.17.25%E2%80%AFPM-1024x577.png?resize=1024%2C577&ssl=1)

这些时间线将向你显示：

- JavaScript 执行（黄色）
- 渲染活动（紫色）
- 绘制（绿色）

关键点：

- 黄色长条，表示 JavaScript 操作耗时
- 频繁出现黄色短条，这可能表明 DOM 操作过多

更深入地了解：

- 点击黄色条可以查看具体的函数调用及其执行时间
- 查看“自下而上”和“调用树”选项卡，以确定哪些函数花费最多时间

这样分析可以帮助你准确查明 DOM 操作代码可能在何处导致性能问题，从而进行有针对性的优化。

### 性能调试资源

Chrome 开发团队的文章：

- [Fixing memory issues](https://developer.chrome.com/docs/devtools/memory-problems)
- [Chrome Docs on Recording heap snapshots](https://developer.chrome.com/docs/devtools/memory-problems/heap-snapshots)
- [Chrome Performance tab reference docs](https://developer.chrome.com/docs/devtools/performance/reference)

进一步涵盖内存和性能分析以及 Chrome 开发工具的课程：

- [Blazingly Fast JS](https://frontendmasters.com/courses/blazingly-fast-js/?utm_source=boost&utm_medium=blog&utm_campaign=dom-patterns) by ThePrimeagen
- [Web App Performance](https://frontendmasters.com/courses/web-app-performance/?utm_source=boost&utm_medium=blog&utm_campaign=dom-patterns) by Maximiliano Firtman
- [React Performance](https://frontendmasters.com/courses/react-performance/?utm_source=boost&utm_medium=blog&utm_campaign=dom-patterns) by Steve Kinney
- [Chrome Dev Tools](https://frontendmasters.com/courses/dev-tools/?utm_source=boost&utm_medium=blog&utm_campaign=dom-patterns) by Jon Kuperman
- [Bare Metal JavaScript: The JavaScript Virtual Machine](https://frontendmasters.com/courses/javascript-cpu-vm/?utm_source=boost&utm_medium=blog&utm_campaign=dom-patterns) by Miško Hevery

请记住，高效的 DOM 操作不仅仅涉及使用正确的方法，还涉及了解与 DOM 交互的时间和频率。即使使用有效的方法，过度的操作仍然会导致性能问题。

## DOM 优化的关键要点

在创建性能敏感的 Web 应用程序时，有效的 DOM 操作知识非常重要。虽然现代框架提供了便利性和抽象性，但理解和应用这些低级技术可以显着提高应用程序的性能，尤其是在要求较高的场景中。

回顾一下：

1. 如果可能的话，修改现有元素而不是创建新元素。
2. 使用有效的方法，如 textContent 、 insertAdjacentHTML 和 appendChild 。
3. 仔细管理引用，利用 WeakMap 和 WeakRef 避免内存泄漏。
4. 正确清理事件侦听器以防止不必要的开销。
5. 考虑诸如事件委托之类的技术，以实现更高效的事件处理。
6. 使用 AbortController 等工具可以更轻松地管理多个事件侦听器。
7. 使用 DocumentFragment 进行批量插入，并了解虚拟 DOM 等概念以实现更广泛的优化策略。

请记住，我们的目标并不总是放弃使用框架，转而手动操作 DOM 来处理每个项目。相反，我们的目标是理解这些基本原则，这样您就可以做出明智的决策，知道何时应该使用框架，何时应该在更底层进行优化。内存分析和性能基准测试等工具可以帮助指导这些决策过程。